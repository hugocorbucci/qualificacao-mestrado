%% ------------------------------------------------------------------------- %%
\chapter{Métodos ágeis no contexto do Software Livre}
\label{cap:agile}

Na Agile 2008, Mary Poppendieck conduziu um
\emph{workshop}\footnote{http://submissions.agile2008.org/node/376 -
  Acessado em 16/03/2009} com Christian Reis intitulado \emph{``Open
  Source Meets Agile - What can each teach the other?''}. Seu objetivo
era de discustir práticas de sucesso em um projeto de software livre
que não eram encontradas em métodos ágeis. Desta forma, os
participantes poderiam compreender alguns princípios essenciais que se
aplicando a projetos de software livre e pode melhorar os atuais
métodos ágeis. Um pequeno resumo da discussão pode ser encontrado na
seção \ref{sec:foss-over-agile}.

De um outro ponto de vista, faltam soluções especiais para o
desenvolvimento de software livre nos métodos ágeis mais conhecidos
atualmente. A Seção \ref{sec:agile-improve-os} apresenta como a
criação dessa solução poderia ajudar tanto o software livre quanto a
comunidade de métodos ágeis.

\section{Princípios do Software Livre que os métodos ágeis deveriam
  aprender}
\label{sec:foss-over-agile}

Reis é um desenvolvedor Brasileiro de software livre que trabalha para
a Canonical Inc. no desenvolvimento do LaunchPad, o projeto de
gerenciamento de software para a distribuição Linux Ubuntu. O
\emph{workshop} teve início com a apresentação de Reis sobre como o
LaunchPad é desenvolvido. Três pontos essenciais foram levantados
durante a discussão que deu sequência à apresentação e será descrita
na próxima subseção. O primeiro (Subseção \ref{subsec:commiter})
descreve e discute o papel de \emph{commiter}.%TODO traduzir? Como?
O segundo (Subseção \ref{subsec:publicity}) apresenta os benefícios de
seguir um processo de desenvolvimento que seja público e transparente.
Por fim, o último (Subseção \ref{subsec:crossrev}) aborda o sistema de
revisão crusada dos sistemas que é usado para garantir a comunicação e
a clareza do código.

\subsection{O papel do \emph{commiter}}
\label{subsec:commiter}

Parte do valor que foi identificado no software livre foi o papel do
\emph{commiter}. Um \emph{commiter} é uma pessoa que tem direitos de
adicionar código fonte ao ``galho''\footnote{Um galho de um
  repositório é uma ramificação estrutura de diretórios que guarda os
  arquivos} principal do repositório de controle de versões. O
``galho'' principal é a parte do código que será empacotada para
formar uma nova versão do programa. Aos olhos da comunidade do
software, o commiter é uma pessoa confiável que é muito boa para
avaliar a qualidade do código fonte. Este é o meio encontrado pelas
comunidades de software livre para revisar a grande maioria do código
fonte de forma a reduzir a quantidade de erros e melhorar a clareza do
código.

A maioria dos projetos de software livre tem um grupo muito pequeno de
\emph{commiters}. Frequentemente o líder do projeto é o único
\emph{commiter} e todos os \emph{patches} devem passar por sua
aprovação. De acordo com Riehle \cite{Riehle2007}, existem três níveis
na hierarquia tradicional de um projeto de software livre. O primeiro
nível é o de usuário. Usuários têm o direito de usar o programa,
relatar problems e pedir funcionalidades. O segundo nível é o de
contribuidor. A promoção entre o primeiro e o segundo nível é
implícita. Ela acontece quando um \emph{commiter} aceita os
\emph{patches} do usuário e os envia ao repositório de código no
``galho'' principal. Normalmente, ninguém exceto o \emph{commiter} e o
contribuidor sabem dessa promoção. O terceiro papel é o de
\emph{commiter}. Neste nível, a transição é explícita. Contribuidores
e \emph{commiters} desmontram apoio a um determinado contribuidor e
reconhecem publicamente a qualidade geral de seu trabalho. Por isso,
atingir o nível de \emph{commiter} é um feito valioso que significa
que você produz código de ótima qualidade e está realmente envolvido
com o desenvolvimento do projeto.

%TODO Continuar traduzindo

Agile methods entrust this role to every developer and it was
suggested in the workshop that it might be good to have some sort of
control to the main branch to ensure simplicity of the production
source code. In most agile methods, a team should have a leader (a
Scrum Master in Scrum, a Coach in XP, etc...) that is more experienced
in some aspect than the rest of the team. When this leader does not
have technical knowledge, it is suggested that someone should be
pointed as the ``technical consultant'' to help the leader. Either
way, the technical leader should discuss issues with the developers
and remind them of the practices they should follow.

It looks like a natural suggestion that the team's leader may assume
the role of commiter. It would allow for an external review of the
generated source code ensuring a higher level of clarity. This could
support the pair programming code review not by reducing the amount of
errors but by ensuring a cleaner code. On the other hand, the team's
leader could become the bottleneck for code production or would have
to abandon his other tasks to fulfill this one. An idea here would be
to have a small set of developers being commiters and this role would
circulate. Having the role circulating allows for a better knowledge
spreading and reduces the power weight involved in this role.

\subsection{Public results}
\label{subsec:publicity}

Another important point was the publicity of all results regarding the
project. According to Reis, non OS software can also benefit from
public bug tracking and test results although they will have to accept
some level of code detail to be exposed. Having such public tools
encourages users to participate in the development process since they
understand how the development is improved.

In agile software development, bug tracking and test results are
important information for the development team but no methodology
clearly states that the client or user should be directly in contact
with those tools. However, most say that the client should be
considered part of the development team which can mean he should use
those tools as the rest of the team does. The most used tools are very
crude when considered from a non-developer perspective since few of
them attribute a business meaning to their results. Few initiatives
regarding tests exist on tools\footnote{RSpec - http://rspec.info/ -
  Last accessed 30/09/2008}\footnote{JBehave - http://jbehave.org/ -
  Last accessed 30/09/2008} related to Behaviour Driven Development
\cite{North2006} to produce better reports and bug tracking systems
have been improving over time.

But publicity is not restrained to bugs or tests. Discussions between
members of the project and even with outsiders are always logged in
the mailing lists archives. Discussions outside of the mailing list
are strongly discouraged since they prevent other people to contribue
with comments and ideas.  Those logs help building a documentation for
future users as well as creating a quick feedback system to
newcomers. The practice also serves as a tool to improve respect
between parts since all decisions are archived and saved for future
access.

This sort of traceability is one of the weak points of agile
methods. Most of them suggest that design evolves with time as needed
and that this evolution flows naturally on whiteboards or flip
charts. The problem with this approach is that whiteboards are erased
and flip charts are recycled. Even when those are persisted somehow
(by pictures, transcription or even in the code itself), the
discussion that led to the solution is lost. Talking is a very
effective way to communicate but is also very ephemeral. Once the
conversation is over, it is hard to quickly reach the precise
information you are searching for. Emails have a much lower
communication bandwidth but gain on their ability to search. In a
short term, it is evident that talking is more effective than writing,
especially in small teams. However in a medium or long period, the
gains might outcome (as they do in OS) the losses.

\subsection{Cross reviewing}
\label{subsec:crossrev}

The third point that Reis presented was pretty specific to
LaunchPad. Since LaunchPad is a platform used by other teams to
develop their own project, when there is an API (Application
Programming Interface) modification, a member from an external team
that uses the software (preferably a different one each time) is asked
to review the API change and its motivation. Such change cannot be
added to the trunk of the repository unless it has been approved by
the external reviewer. They call this a cross review of API changes
or, simply, a cross review.

This practice tackles a few problems at once. The commiter role
partially solves the code review problem that is addressed with pair
programming on agile methods. Having a cross review ensures that the
API will be approved by two different developers.

It also greatly improves documentation about that API since the
conversation between the project developer and the user is logged
through the mailing list. This way, future or other users can read and
understand why the API was changed and how to use it when it is best
suited for them. It also helps future changes and simplifications
since it is easy to check whether the condition at the time of the
change still holds on new versions.

Finally, it also helps involving the user or client in the
architectural decisions as well as ensures that he agrees on the
changes. This helps discovering possible requirement problems and
correcting them before they get implemented in the main code
base. Obviously such practice can only apply to some level when the
user is not a developer. Having an external review will help ensuring
API clarity and document the changes but it might not detect
requirement problems if the reviewer is not a user or client.

\section{Agile contributions to improve Open Source}
\label{sec:agile-improve-os}

Most of the problems pointed out so far are related to communication
issues caused by the amount of people involved in a project and their
various knowledge and cultures. Although in OS those matters are taken
to a limit, distributed agile teams face some of the same problems
\cite{Sutherland2007,Maurer2002}.

As Beck suggests \cite{Beck2008}, tools can improve the adoption and
use of agile practices and, therefore, improve a development
process. A fair amount of work has been directed to distributed pair
programming tools\footnote{http://sf.net/projects/xpairtise/ - Last
  accessed 02/10/2008} and studies \cite{Nagappan2003} but very few
tools have been produced to support other practices. Since
communication is at stake, a few other practices are related to it in
agile methods. The following subsections will present those practices
and the tools to improve the OS experience with agile development.

\subsection{Informative Workspace}
\label{subsec:inform-worksp}

This practice suggests that an agile team should work in an
environment that gives them information regarding their work. Beck
assigns a specific role, the tracker role, to the person (or persons)
that should maintain this information available and updated to the
team. With co-located teams, the tracker usually collects metrics
\cite{Sato2007} automatically and selects a few of them to present in
the workspace. Most of the objective metrics are related to the code
base while subjective ones depend on developers' opinions.

Collecting those data is not a hard task but it is usually time
consuming and does not produce immediate benefit to the software.
This is probably the reason why it is very rare to find an OS project
with updated metrics and data in their website. A tool that could
improve such scenario would be a web-based plug in system with a
built-in metrics collection as well as a way to add and present new
metrics. Such tool should be available into OS forge applications to
allow projects to easily connect them to their repository and web
site.

\subsection{Stories}
\label{subsec:stories}

Regarding the planning system, XP suggests that requirements should be
collected in user story cards. The goal is to minimize the amount of
effort required to discover the next step to make and being able to
easily change those requirements priorities over time. OS projects
usually are based on bug tracking systems to store those
requirements. A missing feature is reported as a bug that should be
corrected and discussions and patch suggestions are submitted related
to that ``bug''. The problem with this approach is that changing
priority and setting a release plan is very time consuming and relies
on non documented assumptions (such as ``this release should solve
buts with priority over 8'').  It is also very hard to obtain an
overall view of all the requirements.

Discovering what are the main priorities for the team quickly and
being able to change those priorities according to the community's
feedback is key to develop a working software. To help achieve this, a
tool should be implemented to allow bugs to be seen as movable
elements on a release planning. In order to benefit from the
community's knowledge, the tool should also have the bug's priority
and content set by the users in a similar way as Wikipedia manages its
articles \cite{Surowiecki2004,Tapscott2006,Benkler2006}.

\subsection{Retrospective}
\label{subsec:retrospect}

This practice suggests that the team should get together in a physical
place periodically to discuss the way the project is going. There are
two issues in such practice in OS software teams. The first one is to
have all members of the team present at the same time. The second one
is to have them interact collectively in a shared area placing notes
on time stating problems and good things they felt.

When the team is co-located, this is usually done in a meeting room
with a huge time line and coloured post-its. Our suggestion is to
develop a web-based tool to allow such interaction relating the time
line to the code repository base. The team would be able to annotate
asynchronously the time line. The team leader would occasionally
generate a report sent to all members as well as posted in the
informative workspace.

\subsection{Stand up meetings}
\label{subsec:stand-up}

Stand up meetings, originally suggested in the Scrum methodology,
demands that the whole team gets together and each member explains
quickly what they have been doing and intend to do. This practice
shares the same problem as the retrospective. It involves having the
team together at the same time. Several OS projects already have a
partial solution to this practice using an IRC channel to centralize
the discussions during development time. Although it does not ensure
everyone gets to know what other members are doing, it helps
synchronizing work.

To ensure members get the required knowledge, we suggest that those
IRC channels should be logged and should present the last few messages
to newcomers at every log in. It should also be possible for members
to leave notes from that channel to the bug tracking system as well as
messages to other contributors. On IRC channel, this sort of solution
would usually be implemented by a bot which we intend to associate to
the forge system that should host the previous features.
