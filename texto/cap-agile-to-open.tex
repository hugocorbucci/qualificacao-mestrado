%% ------------------------------------------------------------------------- %%
\chapter{Agile going Open source}
\label{cap:agile}

At Agile 2008, Mary Poppendieck led a
workshop\footnote{http://submissions.agile2008.org/node/376} with
Christian Reis entitled ``Open Source Meets Agile - What can each
teach the other?''. Its goal was to discuss successful practices in an
OS project that could not be found in Agile methods. This way,
attendees would capture some essential principles that apply to open
source projects and could improve agile methods. A short summary of
the discussion can be found in section \ref{sec:foss-over-agile}.
Thinking the other way around, agile methodologies lack some special
solutions related to OS development. Section
\ref{sec:agile-improve-os} presents how creating this solution
would help OS software developmentand also benefits agile methods.

\section{FOSS principles agile should learn from}
\label{sec:foss-over-agile}

Reis is a Brazilian OS developer working at Canonical Inc. on the
development of LaunchPad, the project management software for Ubuntu
Linux distribution. The workshop started with Reis' presentation on
how LaunchPad is developed. Three main points were highlighted during
the discussions that followed the presentation and will be described
in the next subsection. The first one (Section
\ref{subsec:commiter}) describes and discusses the role of
commiter. The second one (Section \ref{subsec:publicity}) presents
the benefits of having a transparent and public process and the last
(Section \ref{subsec:crossrev}) talks about cross reviewing systems
used to ensure communication and clarity of the code.

\subsection{The commiter role}
\label{subsec:commiter}

Part of the value that was identified in OS was the role of commiter.
A commiter is a person that has rights to add source code to the trunk
branch of the version control repository. The trunk branch is the
portion of the code that is packaged to form a new version of the
software. It means that the software community trusts the commiter to
evaluate source code. This is the OS way to have most parts of the
software source code reviewed to reduce the amount of errors and
improve the code clarity.

Most OS projects have a very small team of commiters. Frequently the
project leader is the only commiter and all patches must be suggested
to her. According to Riehle \cite{Riehle2007}, there are three levels
in OS common hierarchy. The first level is to be a user. Being a user,
you get the right to use the software, report bugs and request
features. The second level is being a contributor. The promotion
between the first and the second level is implicit. It happens when a
commiter accepts your patch and sends it to the trunk. Usually, nobody
except the commiter and the contributor know about this change. The
third role is the commiter. At this level, the transition is
explicit. Contributors and commiters vouch for a contributor and
recognize publicly the overall quality of his work. Reaching the
commiter level is a very valuable promotion that means you produce
good quality code and is involved in the project's development.

Agile methods entrust this role to every developer and it was
suggested in the workshop that it might be good to have some sort of
control to the main branch to ensure simplicity of the production
source code. In most agile methods, a team should have a leader (a
Scrum Master in Scrum, a Coach in XP, etc...) that is more experienced
in some aspect than the rest of the team. When this leader does not
have technical knowledge, it is suggested that someone should be
pointed as the ``technical consultant'' to help the leader. Either
way, the technical leader should discuss issues with the developers
and remind them of the practices they should follow.

It looks like a natural suggestion that the team's leader may assume
the role of commiter. It would allow for an external review of the
generated source code ensuring a higher level of clarity. This could
support the pair programming code review not by reducing the amount of
errors but by ensuring a cleaner code. On the other hand, the team's
leader could become the bottleneck for code production or would have
to abandon his other tasks to fulfill this one. An idea here would be
to have a small set of developers being commiters and this role would
circulate. Having the role circulating allows for a better knowledge
spreading and reduces the power weight involved in this role.

\subsection{Public results}
\label{subsec:publicity}

Another important point was the publicity of all results regarding the
project. According to Reis, non OS software can also benefit from
public bug tracking and test results although they will have to accept
some level of code detail to be exposed. Having such public tools
encourages users to participate in the development process since they
understand how the development is improved.

In agile software development, bug tracking and test results are
important information for the development team but no methodology
clearly states that the client or user should be directly in contact
with those tools. However, most say that the client should be
considered part of the development team which can mean he should use
those tools as the rest of the team does. The most used tools are very
crude when considered from a non-developer perspective since few of
them attribute a business meaning to their results. Few initiatives
regarding tests exist on tools\footnote{RSpec - http://rspec.info/ -
  Last accessed 30/09/2008}\footnote{JBehave - http://jbehave.org/ -
  Last accessed 30/09/2008} related to Behaviour Driven Development
\cite{North2006} to produce better reports and bug tracking systems
have been improving over time.

But publicity is not restrained to bugs or tests. Discussions between
members of the project and even with outsiders are always logged in
the mailing lists archives. Discussions outside of the mailing list
are strongly discouraged since they prevent other people to contribue
with comments and ideas.  Those logs help building a documentation for
future users as well as creating a quick feedback system to
newcomers. The practice also serves as a tool to improve respect
between parts since all decisions are archived and saved for future
access.

This sort of traceability is one of the weak points of agile
methods. Most of them suggest that design evolves with time as needed
and that this evolution flows naturally on whiteboards or flip
charts. The problem with this approach is that whiteboards are erased
and flip charts are recycled. Even when those are persisted somehow
(by pictures, transcription or even in the code itself), the
discussion that led to the solution is lost. Talking is a very
effective way to communicate but is also very ephemeral. Once the
conversation is over, it is hard to quickly reach the precise
information you are searching for. Emails have a much lower
communication bandwidth but gain on their ability to search. In a
short term, it is evident that talking is more effective than writing,
especially in small teams. However in a medium or long period, the
gains might outcome (as they do in OS) the losses.

\subsection{Cross reviewing}
\label{subsec:crossrev}

The third point that Reis presented was pretty specific to
LaunchPad. Since LaunchPad is a platform used by other teams to
develop their own project, when there is an API (Application
Programming Interface) modification, a member from an external team
that uses the software (preferably a different one each time) is asked
to review the API change and its motivation. Such change cannot be
added to the trunk of the repository unless it has been approved by
the external reviewer. They call this a cross review of API changes
or, simply, a cross review.

This practice tackles a few problems at once. The commiter role
partially solves the code review problem that is addressed with pair
programming on agile methods. Having a cross review ensures that the
API will be approved by two different developers.

It also greatly improves documentation about that API since the
conversation between the project developer and the user is logged
through the mailing list. This way, future or other users can read and
understand why the API was changed and how to use it when it is best
suited for them. It also helps future changes and simplifications
since it is easy to check whether the condition at the time of the
change still holds on new versions.

Finally, it also helps involving the user or client in the
architectural decisions as well as ensures that he agrees on the
changes. This helps discovering possible requirement problems and
correcting them before they get implemented in the main code
base. Obviously such practice can only apply to some level when the
user is not a developer. Having an external review will help ensuring
API clarity and document the changes but it might not detect
requirement problems if the reviewer is not a user or client.

\section{Agile contributions to improve Open Source}
\label{sec:agile-improve-os}

Most of the problems pointed out so far are related to communication
issues caused by the amount of people involved in a project and their
various knowledge and cultures. Although in OS those matters are taken
to a limit, distributed agile teams face some of the same problems
\cite{Sutherland2007,Maurer2002}.

As Beck suggests \cite{Beck2008}, tools can improve the adoption and
use of agile practices and, therefore, improve a development
process. A fair amount of work has been directed to distributed pair
programming tools\footnote{http://sf.net/projects/xpairtise/ - Last
  accessed 02/10/2008} and studies \cite{Nagappan2003} but very few
tools have been produced to support other practices. Since
communication is at stake, a few other practices are related to it in
agile methods. The following subsections will present those practices
and the tools to improve the OS experience with agile development.

\subsection{Informative Workspace}
\label{subsec:inform-worksp}

This practice suggests that an agile team should work in an
environment that gives them information regarding their work. Beck
assigns a specific role, the tracker role, to the person (or persons)
that should maintain this information available and updated to the
team. With co-located teams, the tracker usually collects metrics
\cite{Sato2007} automatically and selects a few of them to present in
the workspace. Most of the objective metrics are related to the code
base while subjective ones depend on developers' opinions.

Collecting those data is not a hard task but it is usually time
consuming and does not produce immediate benefit to the software.
This is probably the reason why it is very rare to find an OS project
with updated metrics and data in their website. A tool that could
improve such scenario would be a web-based plug in system with a
built-in metrics collection as well as a way to add and present new
metrics. Such tool should be available into OS forge applications to
allow projects to easily connect them to their repository and web
site.

\subsection{Stories}
\label{subsec:stories}

Regarding the planning system, XP suggests that requirements should be
collected in user story cards. The goal is to minimize the amount of
effort required to discover the next step to make and being able to
easily change those requirements priorities over time. OS projects
usually are based on bug tracking systems to store those
requirements. A missing feature is reported as a bug that should be
corrected and discussions and patch suggestions are submitted related
to that ``bug''. The problem with this approach is that changing
priority and setting a release plan is very time consuming and relies
on non documented assumptions (such as ``this release should solve
buts with priority over 8'').  It is also very hard to obtain an
overall view of all the requirements.

Discovering what are the main priorities for the team quickly and
being able to change those priorities according to the community's
feedback is key to develop a working software. To help achieve this, a
tool should be implemented to allow bugs to be seen as movable
elements on a release planning. In order to benefit from the
community's knowledge, the tool should also have the bug's priority
and content set by the users in a similar way as Wikipedia manages its
articles \cite{Surowiecki2004,Tapscott2006,Benkler2006}.

\subsection{Retrospective}
\label{subsec:retrospect}

This practice suggests that the team should get together in a physical
place periodically to discuss the way the project is going. There are
two issues in such practice in OS software teams. The first one is to
have all members of the team present at the same time. The second one
is to have them interact collectively in a shared area placing notes
on time stating problems and good things they felt.

When the team is co-located, this is usually done in a meeting room
with a huge time line and coloured post-its. Our suggestion is to
develop a web-based tool to allow such interaction relating the time
line to the code repository base. The team would be able to annotate
asynchronously the time line. The team leader would occasionally
generate a report sent to all members as well as posted in the
informative workspace.

\subsection{Stand up meetings}
\label{subsec:stand-up}

Stand up meetings, originally suggested in the Scrum methodology,
demands that the whole team gets together and each member explains
quickly what they have been doing and intend to do. This practice
shares the same problem as the retrospective. It involves having the
team together at the same time. Several OS projects already have a
partial solution to this practice using an IRC channel to centralize
the discussions during development time. Although it does not ensure
everyone gets to know what other members are doing, it helps
synchronizing work.

To ensure members get the required knowledge, we suggest that those
IRC channels should be logged and should present the last few messages
to newcomers at every log in. It should also be possible for members
to leave notes from that channel to the bug tracking system as well as
messages to other contributors. On IRC channel, this sort of solution
would usually be implemented by a bot which we intend to associate to
the forge system that should host the previous features.
